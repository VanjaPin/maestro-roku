import "pkg:/source/ml/ItemViewManager.bs"

namespace list
  class RowItemViewManager extends list.ItemViewManager
    public row = invalid
    public lastRowIsRendered = "none"
    public isFlowSupported = false

    function new(l as types.node, row as types.node, container as types.node, componentPool as types.node, minPos as integer, maxPos as integer)
      super("RowItemViewManager", l, container, componentPool, 0, minPos, maxPos)
      m.row = row

      'TODO - make configurable - or calculate on cell size
      m.lookAheadDistance = maxPos * 1.5
      m.lookBehindDistance = maxPos * 1.5
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ overridden
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    public override function reset()
      m.log.info("releasing", m.renderersByContentId.count(), "row children")
      for each id in m.renderersByContentId
        m.componentPool@.releaseComponent(m.renderersByContentId[id])
      end for
      m.renderersByContentId = {}
      super.reset()
    end function


    override function createRenderers(content as types.node, forceSync = false as boolean) as boolean
      ' ? "::: CREATE RENDERERS" ; m.renderersByContentId
      'renderers are created as needed
      m.previousRendereredByContentId = m.renderersByContentId
      m.renderersByContentId = {}
      return true
    end function

    override function updateLayout() as void
      m.log.info("ROW updateLayout")
      m.rects = []
      m.visibleItems = []
      m.cellInfos = []

      m.rowInfos = invalid
      if m.content = invalid
        return
      end if

      index = 0
      ' m.contentGroup.translation = [0, 0]
      focusSettings = m.settings.focusSettings
      x = 0
      for each item in m.content.getChildren(-1, 0)
        ' ? ">>>> laying out ", item.title
        settings = list.listMixin.getCellSettings(m.owner.content, m.content, item)
        xSpace = settings.space

        m.rects.push({
          translation: [x, 0],
          size: settings.size
          index: index
          rowIndex: m.row.index
          visible: true
        })
        maxPos = m.maxPos - settings.size[0] - xSpace

        positions = [
          new list.ComponentPosition(x, 0) 'normal
          new list.ComponentPosition(x, maxPos) 'float-scroll
        ]

        cellInfo = new list.ComponentInfo(settings.size, focusSettings, positions, focusSettings.horizAnimStyle = "floating", index, index)
        cellInfo.index = index
        m.cellInfos.push(cellInfo)

        'TODO - for now, no vis options for rows children..
        m.visibleItems.push(item)

        x += settings.size[m.axes] + xSpace
        index++
      end for

      m.numberOfItems = m.visibleItems.count()
    end function

    override function shouldUpdateRenderedIndexes(direction as integer, index as integer)
      return true
    end function

    override function applyRenderStateMap(renderStateMap as types.assocarray)
      m.log.info("ROW applyRenderStateMap", m.row.index, m.row.isRendered)
      m.renderedComponents = []
      if m.row.isRendered
        for each id in renderStateMap
          m.applyrenderStateForCell(id, renderStateMap[id])
        end for
      else
        ' ? "ROW IS NOT !! RENDERED" ; m.row.index
        for each id in renderStateMap
          m.applyrenderStateForCell(id, "none")
        end for
      end if

      ' ? " RENDERED COMPONENTS IS NOW "; m.renderedComponents
      m.lastRowIsRendered = m.row.isRendered
    end function

    function applyrenderStateForCell(id as string, renderState as string)
      m.log.verbose("applyrenderStateForCell", id, renderState)
      ' ? "APPLY RENDER STATE FOR CELL"
      index = id.toInt()
      ' isRendered = m.row.isRendered
      item = m.content.getChild(index)
      cell = invalid
      if item <> invalid
        itemId = item.id
        if renderState = "rendered"
          cell = m.renderersByContentId[itemId]
          if cell = invalid
            settings = list.listMixin.getCellSettings(m.owner.content, m.content, item)
            ' ? "GETTING CELL " ; id ; " " ; settings.compName ; " " ; m.__classname
            cell = m.componentPool@.getComponent(settings.compName)

            if cell = invalid
              cell = m.previousRendereredByContentId[itemId]
            end if
            if cell <> invalid
              cell.index = index
              cell.translation = m.rects[index].translation

              cell.initialState = {
                row: m.row
                rowIndex: m.row.index
                list: m.owner
                size: m.rects[index].size
                content: item
              }

              cell.visible = true
              ' cell.visible = isRendered

              ' ? ">>>>>>>> " ; isRendered

              ' if isRendered
              cell.listEvent = { "name": "didEnter" }
              ' end if

              if m.lastScrollEvent <> invalid
                cell.listEvent = m.lastScrollEvent
              end if

              m.container.appendChild(cell)
            else
              ? ">>ERR no cell for " ; settings.compName
            end if
          else
            cell.translation = m.rects[index].translation
          end if
          if cell <> invalid
            m.renderersByContentId[itemId] = cell
            m.renderedComponents.push(cell)
            m.previousRendereredByContentId.delete(itemId)
          end if
        else
          cell = m.renderersByContentId[itemId]
          if cell <> invalid
            m.componentPool@.releaseComponent(cell)
            m.renderersByContentId.delete(itemId)
            m.previousRendereredByContentId.delete(itemId)
            ' ? " REMOVING " ; cell.id
          else
            'this is almost certainly due to trying to release a cell during setting content
            ' ? " COULD NOT FIND CELL TO RELEASE" ; id.
          end if
          cell = invalid
        end if
      end if
      'ensure that the componentconfig has a component for a dynamically generated cell index
      componentConfig = m.cellInfos[index]
      componentConfig.component = cell
    end function

    override function getRenderer(index as integer)
      if m.content <> invalid
        item = m.content.getChild(index)
        if item <> invalid
          return m.renderersByContentId[item.id]
        else
          ' ? "ERROR could not find renderer for ", index
          return invalid
        end if
      else
        return invalid
      end if
    end function

    override function setIsScrolling(isScrolling as boolean, isLong as boolean, startIndex as integer) as void
      ? "++++ setIsScrolling" ; isScrolling ; " MIS " ; m.isScrolling
      if m.isScrolling = isScrolling
        return
      end if
      m.scrollingStartIndex = isScrolling ? startIndex: -1
      m.isScrolling = isScrolling

      m.row.isScrolling = isScrolling

      m.owner.isScrolling = isScrolling

      event = {
        name: isScrolling ? "scrollStart" : "scrollStop"
        startIndex: m.scrollingStartIndex
        long: isLong
        startIndex: m.scrollingStartIndex
      }
      m.lastScrollEvent = isScrolling ? event : invalid


      for each id in m.renderersByContentId
        comp = m.renderersByContentId[id]
        comp.listEvent = event
      end for

      m.owner.listEvent = {
        name: event.name
        index: m.row.index
        long: isLong
        startIndex: startIndex
      }
      ' ? "++++ row - listEvent " ; formatJson(m.row.listEvent)
      ' ? "++++ owner - listEvent " ; formatJson(m.owner.listEvent)
    end function

    protected override function onContentItemsChange(changes as types.array)
      m.log.info("updating row renderers due to contents change")
      ' ? "ROW CHANGES"
      oldNumComponents = m.itemScroller.numberOfComponents
      m.processRemovedCells(changes)
      ' ? "FORCING LAYOUT"
      m.forceUpdateLayout()
      ' ? m.__classname ; " I " ; m.itemScroller.index ; " C " ; m.content.length ; m.content.length
      if m.itemScroller.index >= m.content.length
        m.itemScroller.index = clamp(m.itemScroller.index, 0, m.content.length - 1)
      end if
      m.updateRenderedComponents(m.direction, m.itemScroller.index, true)
      m.itemScroller.getComponentInfos(true)
      m.itemScroller.processChanges(changes)
      ' ? " LLLL " ; m.itemScroller.numberOfComponents ; " ONC " ; oldNumComponents
      m.rowInfos = invalid
      if (m.itemScroller.numberOfComponents = 0 and oldNumComponents > 0) or (oldNumComponents = 0 and m.itemScroller.numberOfComponents > 0)
        ' ? "::::::::::::::::: SUB ITEMS ZERO CHANGE - TELL LIST"
        m.owner@.forceUpdate()
      end if
      if m.row.isFocused
        ' m.itemScroller.forceFocusOnIndex(m.itemScroller.index)
        m.owner.focusedCellIndex = m.itemScroller.index
      end if
    end function


    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Private Methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    private function processRemovedCells(changes as types.array)
      m.log.info("processing removed cells")
      for each change in changes
        ' ? ">>> got change " ; change.type
        if change.type = "remove"
          m.log.info("removing cell at index", change.index)
          item = change.child

          if item <> invalid
            cell = m.renderersByContentId[item.id]
            if cell <> invalid
              m.componentPool@.releaseComponent(cell)
              m.renderersByContentId.delete(item.id)
            else
              'this is almost certainly due to trying to release a cell during setting content
              m.log.error("could not find cell to release", item.id)
            end if
          else
            m.log.error("could not find cell to release")
          end if
        else if change.type = "clear" or change.type = "sort" or change.type = "updated"
          'we've reset the list - all renderers are going now
          m.renderersByContentId = {}
          m.tidyUpUnusedRenderers()
        end if
      end for
    end function

  end class
end namespace