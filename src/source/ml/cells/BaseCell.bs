import "pkg:/source/core/Utils.bs"
import "pkg:/source/view/ViewUtils.bs"
import "pkg:/source/ml/ItemDelegateMixin.bs"

namespace list
  @node("ml_BaseCell", "Group")
  class BaseCell

    public index = -1

    @observer("onDebugMChange")
    public __debugM = false

    ' any item in a list will have this set whenever it gets recycled
    @observer("onInitialStateChange")
    public initialState as types.AssocArray

    @observer("onIsPrebaked")
    public isPrebaked = false

    public isInViewPort = false

    public listEvent as types.AssocArray

    private isViewCreated = false
    private isRecyclePending = true

    public content as types.Node
    protected list
    protected row
    protected size as types.Array

    function new()
      list.itemDelegateMixin.setDelegate()
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Public Methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    public function recycle()
      if not m.isViewCreated
        m._createViews()
      end if
      if m.isRecyclePending
        m._onContentChange(m.content)
      end if
    end function

    public function forceUpdate()
      m.isRecyclePending = true
      m.recycle()
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ callbacks
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function onDebugMChange()
      setOrAddNodeField(m.top, "__m", m)
    end function

    protected function onIsPrebaked(value as boolean)
      'can do things like:
      ' m.createViews()
      ' m.isViewCreated = true
    end function

    private function _createViews()
      if m.content <> invalid
        m.createViews()
        m.isViewCreated = true
      end if
    end function

    private function _onContentChange(content as types.node)
      m.onContentChange(content)
      m.isRecyclePending = false
    end function

    protected function onInitialStateChange(state as string)
      m.list = state.list
      m.row = state.row
      m.size = state.size
      m.content = state.content
      m.isRecyclePending = true
      m.recycle()
    end function

    protected function createViewsFromStyleJson(childrenJson as types.array, targetNode as types.node, assignViewsToM = true as boolean, mTarget = invalid as types.assocarray)
      if mTarget = invalid
        mTarget = m
      end if
      view.createViewsFromStyleJson(childrenJson, targetNode, assignViewsToM, mTarget)
    end function

    protected function updateViewsWithStyleJson(json as types.array, mTarget = invalid as types.assocarray)
      if mTarget = invalid
        mTarget = m
      end if
      view.updateViewsWithStyleJson(json, mTarget)
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ abstract methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    protected function createViews()
      'override me!
    end function

    protected function onContentChange(content as types.node)
      'override me
    end function


  end class
end namespace