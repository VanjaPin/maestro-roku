import "pkg:/source/ml/ItemViewManager.bs"
import "pkg:/source/ml/ComponentInfo.bs"

namespace list
  class GridRowItemViewManager extends list.ItemViewManager
    public row = invalid
    public numRows = 0
    public numCols = 1
    public componentBufferMode = "rendered"
    public lastRowIsRendered = "none"
    public isFlowSupported = false
    private maxRowPos = 0
    private rowOffsets = []
    private firstFlowIndex = 0
    private otherRowScreenPos = 0
    private perRowHeight = 0
    private isVerticalFlowFocusAllowed = false
    public upScreenPosition = 0
    public downScreenPosition = 0
    private lastFlowDirection = 1

    function new(l as types.node, row as types.node, container as types.node, componentPool as types.node, minPos as integer, maxPos as integer)
      super("GridRowItemViewManager", l, container, componentPool, 0, minPos, maxPos)
      m.row = row

      m.lookAheadDistance = maxPos * 1.5
      m.lookBehindDistance = maxPos * 1.5
    end function

    protected override function updateScreenRect()
      'bs:disable-next-line
      bounds = m.owner.sceneBoundingRect()
      m.screenRect = { translation: [bounds.x, bounds.y], size: [m.owner.width, m.maxRowPos] }
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Public Methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function getRowIndexForItemIndex(index as integer) as integer
      return fix(index / m.numCols)
    end function

    function getCellInfosInRow(rowIndex as integer) as types.array
      infos = []
      firstIndex = rowIndex * m.numCols
      for i = firstIndex to firstIndex + m.numCols - 1
        info = m.cellInfos[i]
        if info <> invalid
          infos.push(info)
        end if
      end for
      return infos
    end function

    function getRenderersInRow(rowIndex as integer) as types.array
      infos = m.getCellInfosInRow(rowIndex)
      renderers = []
      for each info in infos
        renderer = m.getRenderer(info.componentIndex)
        if renderer <> invalid
          renderers.push(renderer)
        end if
      end for
      return renderers
    end function

    function getSubIndexAtPosition(position as integer, direction as integer)
      position += m.row.translation[1] 'adjust for position in the list
      p = abs(position)
      i = 0
      position -= m.contentGroup.translation[1] 'adjust for header offsets

      numRows = m.rowOffsets.count() - 1
      for i = numRows to 0 step -1
        ' ? " CHECK ROW " ;i ; " " ; m.rowOffsets[i] ; " >>> "; p
        itemPos = m.rowOffsets[i]
        if p > itemPos
          return clamp(i + 1, 0, numRows)
        end if
      end for

      'we must be at the end! -return last item
      return clamp(i, 0, numRows)
    end function


    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Overridden
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    protected override function getRowInfos(yPosition as integer, forceRecalculate = false as boolean) as types.array
      if forceRecalculate
        m.rowInfos = invalid
      end if
      if m.rowInfos = invalid
        m.rowInfos = []

        height = m.owner.height

        rowHeight = m.settings.rowHeight
        contentOffset = m.settings.contentOffset[1]

        if m.settings.firstRowScreenPos <> m.settings.screenPos
          m.firstFlowIndex = 1
          m.otherRowScreenPos = m.settings.otherRowScreenPos
        else
          m.firstFlowIndex = 0
          m.otherRowScreenPos = m.settings.firstRowScreenPos
        end if
        m.maxRowPos = (m.settings.numRows - 1) * (m.perRowHeight)
        m.upScreenPosition = m.otherRowScreenPos

        if m.isVerticalFlowFocusAllowed
          m.downScreenPosition = m.maxRowPos
        else
          m.downScreenPosition = m.otherRowScreenPos
        end if
        m.updateScreenRect()

        ' ? "+>+>+>>+>+>++>+>+>+>>++>>+>+"
        for i = 0 to m.rowOffsets.count() - 1
          m.rowInfos.push(m.getRowInfo(i, [0, rowHeight], m.rowOffsets[i] - contentOffset, yPosition, height, m.maxRowPos))
          ' ? "LAYING OUT ITEM " ; i ; "RO " ; m.rowOffsets[i]
        end for
        ' ? "+>+>+>>+>+>++>+>+>+>>++>>+>+"
      end if
      return m.rowInfos
    end function

    public override function reset()
      m.log.info("releasing", m.renderersByContentId.count(), "row children")
      for each id in m.renderersByContentId
        m.componentPool@.releaseComponent(m.renderersByContentId[id])
      end for
      m.renderersByContentId = {}
      super.reset()
    end function

    override function createRenderers(content as types.node, forceSync = false as boolean) as boolean
      'renderers are created as needed
      m.previousRendereredByContentId = m.renderersByContentId
      m.renderersByContentId = {}
      return true
    end function

    override function updateLayout() as void
      m.log.info("GRID updateLayout")
      ' ? ""
      ' ? "+>+>>+>+>+>+>++>>++>>+>+>+>+>+>+>>+>+>+>+>"
      ' ? "GRID UPDATE LAYOUT"
      m.rects = []
      m.visibleItems = []
      m.rowOffsets = []
      m.rowInfos = invalid
      m.cellInfos = []
      m.isVerticalFlowFocusAllowed = m.getFocusSettings().vertAnimStyle = "floating"

      if m.content = invalid
        return
      end if

      i = 0
      xSpace = m.settings.space
      m.perRowHeight = m.settings.rowHeight + m.settings.rowSpace

      x = 0
      y = 0
      numItems = m.content.getChildCount()
      children = m.content.getChildren(-1, 0)
      m.numCols = m.settings.numColumns
      m.numCols = m.numCols < 1 ? 1 : m.numCols
      rowIndex = 0
      ' ? "children" ; formatJson(collections.map(children, function(c as object)
      ' return c.title
      ' end function))

      ' ?""
      ' ?""
      ' ?""
      ' ? "LAYING OUT+++++++++++++++++++++++++++++++++"

      while i < numItems
        m.rowOffsets.push(y)

        for col = 0 to m.numCols - 1
          item = children[i]
          if item = invalid
            exit for
          end if
          ' ? "ITEM " ; item.title
          settings = list.listMixin.getCellSettings(m.owner.content, m.content, item)
          m.rects.push({
            translation: [x, y],
            size: settings.size
            index: i
            gridRow: rowIndex
            visible: true
          })

          positions = [
            new list.ComponentPosition(0, x) 'up
            new list.ComponentPosition(0, x) 'down
          ]

          cellInfo = new list.ComponentInfo(settings.size, m.settings.focusSettings, positions, true, i, i)
          cellInfo.index = i
          m.cellInfos.push(cellInfo)
          'TODO - for now, no vis options for rows children..
          m.visibleItems.push(item)

          x += settings.size[m.axes] + xSpace
          i++
        end for

        x = 0
        y += m.perRowHeight
        rowIndex++
      end while

      m.numRows = clamp(m.rowOffsets.count() - 1, 0, m.settings.numRows)
      m.numberOfItems = m.visibleItems.count()
    end function

    private function getRowInfo(rowIndex as integer, size as types.array, yOffset as integer, y as integer, height as integer, maxPos as integer) as list.ComponentInfo

      yOffset += y

      if rowIndex = 0
        screenPos = m.settings.firstRowScreenPos
        ' ? " ROW 0 " ; screenPos
        ' if screenPos > yOffset
        '   screenPos = yOffset
        ' end if
        isFlowFocusAllowed = false

        positions = [
          new list.ComponentPosition(yOffset, screenPos) 'up
          new list.ComponentPosition(yOffset, screenPos) 'down
        ]
      else if rowIndex = 1 and m.settings.otherRowScreenPos <> m.settings.firstRowScreenPos
        screenPos = m.settings.otherRowScreenPos
        ' ? " ROW 1 " ; screenPos
        ' if screenPos > yOffset
        '   screenPos = yOffset
        ' end if
        isFlowFocusAllowed = false
        positions = [
          new list.ComponentPosition(yOffset, screenPos) 'up
          new list.ComponentPosition(yOffset, screenPos) 'down
        ]
      else
        screenPos = m.settings.otherRowScreenPos
        isFlowFocusAllowed = m.isVerticalFlowFocusAllowed
        if m.isVerticalFlowFocusAllowed
          downScreenPos = (m.settings.numRows - 1) * (m.perRowHeight)
        else
          downScreenPos = 0
        end if
        ' ? "ROW SCREEN POS" ; rowIndex ; " " ; yOffset ; " Y " ; yOffset ; " F "; m.firstFlowIndex ; " SP "; screenPos
        positions = [
          new list.ComponentPosition(yOffset, screenPos) 'up
          ' new list.ComponentPosition(yOffset, screenPos) 'down
          new list.ComponentPosition(yOffset - downScreenPos, screenPos) 'down
        ]
      end if
      'note - col width is irrelevant
      return new list.ComponentInfo(size, m.settings, positions, isFlowFocusAllowed, rowIndex, rowIndex)
    end function

    override function shouldUpdateRenderedIndexes(direction as integer, index as integer)
      return true
    end function

    override function applyRenderStateMap(renderStateMap as types.assocarray)
      m.log.info("ROW applyRenderStateMap", m.row.index, m.row.isRendered)
      ' ? "______________________________ ARSM" ; m.__classname
      m.renderedComponents = []
      if m.row.isRendered
        for each id in renderStateMap
          m.applyrenderStateForCell(id, renderStateMap[id])
        end for
      else
        ' ? "ROW IS NOT !! RENDERED" ; m.row.index
        for each id in renderStateMap
          m.applyrenderStateForCell(id, "none")
        end for
      end if

      m.lastRowIsRendered = m.row.isRendered
    end function

    function applyrenderStateForCell(id as string, renderState as string)
      m.log.verbose("applyrenderStateForCell", id, renderState)
      index = id.toInt()
      ' isRendered = m.row.isRendered
      item = m.content.getChild(index)

      cell = invalid
      if item <> invalid
        itemId = item.id
        ' ? " GRID===========================" ; itemid
        if renderState = "rendered"
          cell = m.renderersByContentId[itemId]
          if cell = invalid
            cell = m.previousRendereredByContentId[itemId]
          end if
          if cell = invalid
            settings = list.listMixin.getCellSettings(m.owner.content, m.content, item)
            ' ? "GETTING CELL " ; itemId ; " " ; settings.compName ; " " ; m.__classname
            cell = m.componentPool@.getComponent(settings.compName)

            if cell <> invalid
              cell.index = index
              cell.translation = m.rects[index].translation

              cell.initialState = {
                row: m.row
                list: m.owner
                size: m.rects[index].size
                content: item
              }

              cell.visible = true
              ' cell.visible = isRendered

              ' ? ">>>>>>>> is visible "

              ' if isRendered
              cell.listEvent = { "name": "didEnter" }
              ' end if

              if m.lastScrollEvent <> invalid
                cell.listEvent = m.lastScrollEvent
              end if

              m.container.appendChild(cell)
            else
              m.log.error("could not make cell of type ", settings.compName)
            end if
          else
            cell.translation = m.rects[index].translation
            ' might have changed
            cell.index = index
            cell.initialState = {
              row: m.row
              list: m.owner
              size: m.rects[index].size
              content: item
            }

            cell.visible = true
          end if
          if cell <> invalid
            ' ? " SET cell at index "; index ;" to " ; itemId; " " ; item.title
            ' ? " RENDERED COMPS IS NOW len" ; m.renderedComponents.count()
            m.renderedComponents.push(cell)
            m.previousRendereredByContentId.delete(itemId)
            m.renderersByContentId[itemId] = cell
          end if
        else
          cell = m.renderersByContentId[itemId]
          if cell <> invalid
            ' ? "RELEASING " ; id
            m.componentPool@.releaseComponent(cell)
            m.renderersByContentId.delete(itemId)
            m.previousRendereredByContentId.delete(itemId)
          else
            'this is almost certainly due to trying to release a cell during setting content
            ' ? " COULD NOT FIND CELL TO RELEASE" ; id
          end if
        end if
      end if
      componentConfig = m.cellInfos[index]
      componentConfig.component = cell
    end function

    override function getRenderer(index as integer)
      if m.content <> invalid
        item = m.content.getChild(index)
        if item <> invalid
          return m.renderersByContentId[item.id]
        else
          m.log.error("ERROR could not find renderer for ", index)
          ? " GRID COULD NOT GET RENDERER FOR index" ; index
          return invalid
        end if
      else
        return invalid
      end if
    end function

    override function setIsScrolling(isScrolling as boolean, isLong as boolean, startIndex as integer) as void
      if m.isScrolling = isScrolling
        return
      end if
      m.scrollingStartIndex = isScrolling ? startIndex: -1
      m.isScrolling = isScrolling

      ' ? "++++ setIsScrolling" ; isScrolling
      m.row.isScrolling = isScrolling

      m.owner.isScrolling = isScrolling

      event = {
        name: isScrolling ? "scrollStart" : "scrollStop"
        startIndex: m.scrollingStartIndex
        long: isLong
        startIndex: m.scrollingStartIndex
      }
      m.lastScrollEvent = isScrolling ? event : invalid


      for each id in m.renderersByContentId
        comp = m.renderersByContentId[id]
        comp.listEvent = event
      end for

      m.owner.listEvent = {
        name: event.name
        index: m.row.index
        long: isLong
        startIndex: startIndex
      }
      ' ? "++++ row - listEvent " ; formatJson(m.row.listEvent)
      ' ? "++++ owner - listEvent " ; formatJson(m.owner.listEvent)
    end function

    private function getHeightOfGridRow()

      return m.numRows * (m.settings.rowHeight + m.settings.space) + m.settings.headerSettings.height
    end function

    private function getLastRowOffset() as integer
      if m.rowOffsets.count() > 0
        return m.rowOffsets[m.rowOffsets.count() - 1]
      else
        return 0
      end if
    end function

    private function getRowOffset(rowIndex as integer) as integer
      if m.rowOffsets.count() > rowIndex
        return m.rowOffsets[rowIndex]
      else
        return 0
      end if
    end function

    override function getComponentsInViewPort(startOffset as integer)
      compStates = {}
      'NOTE - for now, all grid items are on screen - we can tighten it up later

      ' sStart = m.screenRect.translation[m.axes] + startOffset
      ' sEnd = sStart + m.screenRect.size[m.axes]

      for each comp in m.renderedComponents
        if comp.index <> invalid
          cRect = m.rects[comp.index]
          if cRect <> invalid
            compStates[comp.id] = true
            'TODO - minimize what is in view port
            '   cStart = cRect.translation[m.axes]
            '   cEnd = cStart + cRect.size[m.axes]
            '   if (cStart >= sStart and cStart <= sEnd) or (cEnd >= sStart and cEnd <= sEnd)
            '     compStates[comp.id] = true
            '   else
            '     compStates[comp.id] = false
            '   end if
          end if
        else
          ' ? "comp index not set!"
        end if
        ' m.log.info(compStates[comp.id], "sStart", sStart, "sEnd", sENd, "cStart", cStart, "cEnd", cENd)
      end for

      return compStates
    end function

    override function getRenderedIndexes(direction as integer, index as integer)
      return {
        startIndex: 0
        endIndex: m.content = invalid ? 0 : m.visibleItems.count() - 1
      }
    end function

    protected override function onContentItemsChange(changes as types.array)
      m.log.info("updating row renderers due to contents change")

      ' ? " CHANGE GRID ROW " ; m.content.length ; " I " ; m.itemScroller.index
      numRows = m.rowOffsets.count()
      m.processRemovedCells(changes)
      m.forceUpdateLayout()


      m.updateRenderedComponents(m.itemScroller.direction, m.itemScroller.index, true)

      m.itemScroller.getComponentInfos(true)
      if m.itemScroller.index >= m.itemScroller.numberOfComponents
        m.itemScroller.index = clamp(m.itemScroller.index, 0, m.itemScroller.numberOfComponents - 1)
        ' ? "NEEDED TWEAK TO index is now: " ; m.itemScroller.index
      end if
      if m.itemScroller.componentInfos.count() <> numRows
        m.itemScroller.chooseComponentInfoForScrollingIntoRow(m.itemScroller.componentInfos[m.itemScroller.index])
        ' ? "NEED TO TELL LIST!!!  num rows now " ; m.itemScroller.componentInfos.count()
        m.owner@.forceUpdate()
      end if

      m.itemScroller.processChanges(changes)
      ' if m.row.isFocused
      '   m.itemScroller.forceFocusOnIndex(m.itemScroller.index)
      '   m.owner.focusedCellIndex = m.itemScroller.index
      ' end if

      ' ? "+++++++++++++++++++++++++++++++++++++++++++"
    end function


    override function isVerticalFlowFocusPossible(info as list.componentInfo, direction as integer, activeScreenPos as integer, scrollPos as integer)


      if not m.isVerticalFlowFocusAllowed
        return false
      end if
      ' ? " grid isVerticalFlowFocusPossible "
      ' ? info.componentIndex ; " NR "; m.settings.numRows ; " FRI " ; m.firstFlowIndex ; " ASP "; activeScreenPos ; " SP "; scrollPos

      if info.componentIndex <= m.firstFlowIndex and direction = 1
        return false
      end if

      activeScreenPos = m.lastFlowDirection = -1 ? m.upScreenPosition : m.downScreenPosition
      m.lastFlowDirection = direction

      ' ? " CHANGING ACTIVE SCREEN POS TO FIRST ROW POS"
      ' end if
      rowStartPos = scrollPos + activeScreenPos

      firstRowOnScreen = m.getSubIndexAtPosition(rowStartPos, direction)
      ' ? "L>>>>>>"
      ' ? "L>>>>>> ; first on screen" ; firstRowOnScreen
      ' ? "L>>>>>> ; last row ALLOWED screen "; firstRowOnScreen + (m.settings.numRows - 1)
      ' ? "L>>>>>> row "; info.componentIndex
      ' ? "L>>>>>> SP "; scrollPos ; " ASP "; activeScreenPos
      if direction = -1
        return info.componentIndex >= firstRowOnScreen
      else
        return info.componentIndex <= firstRowOnScreen + (m.settings.numRows - 1)
      end if
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Private Methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    private function processRemovedCells(changes as types.array)
      m.log.info("processing removed cells")
      for each change in changes
        ' ? "GOT CHANGE TYPE "; change.type
        if change.type = "remove"
          m.log.info("removing cell at index", change.index)
          item = change.child

          if item <> invalid
            ' ? " REMOVING CELL", item.id
            cell = m.renderersByContentId[item.id]
            if cell <> invalid
              m.componentPool@.releaseComponent(cell)
              m.renderersByContentId.delete(item.id)
            else
              'this is almost certainly due to trying to release a cell during setting content
              ' ? "NO CELL item.id", item.id
              m.log.error("could not find cell to release", item.id)
            end if
          else
            ' ? "NO CELL item.id", change.index
            m.log.error("could not find cell to release")
          end if
        end if
      end for
    end function

  end class
end namespace