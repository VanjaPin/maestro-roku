import "pkg:/source/core/BaseClass.bs"
import "pkg:/source/ml/ListMixin.bs"
import "pkg:/source/ml/ItemScroller.bs"
import "pkg:/source/ml/ComponentInfo.bs"

namespace list
  class ItemViewManager extends BaseClass

    public screenRect = { translation: [0, 0], size: [1920, 1080] }
    public componentBufferMode = "none"
    private componentPool as types.node

    'owning views
    'we wrap the container to make it very easy to reason about content offsets
    public container = invalid
    public owner = invalid
    public delegate = invalid
    public contentGroup = invalid
    public cellInfos = []
    private rowInfos as types.array
    private renderersByContentId = {}


    'tracking used for reusing cells during multi-render batches
    private previousRendereredByContentId = {}

    'content
    public content = invalid
    public rects = []
    public settings = invalid
    public listSettings = invalid

    'tracking
    public direction = 0
    public visibleItems = []
    public numberOfItems = 0
    public numberOfVisibleItems = 0

    ' 0 - x, 1 - y, 2 - both
    public axes = 0
    public minPos = 0
    public maxPos = 1080
    public lookAheadDistance = 1000
    public lookBehindDistance = 1000
    public lastRenderedIndexes = { startIndex: -1, endIndex: -1 }
    public lastScrollIndex = 0
    public lastScrollDirection = 0
    public renderedComponents = []
    public isScrolling = false
    public scrollingStartIndex = -1
    private isRendering = false

    'TODO - move into settings or calculate this
    private renderedIndexUpdateInterval = 10

    'stored so we can send it with initialstate
    public lastScrollEvent as types.assocarray
    public itemScroller as list.ItemScroller

    function new(name as string, owner as types.node, container as types.node, componentPool as types.node, axes as types.array, minPos as integer, maxPos as integer)
      super(name)
      m.container = container
      m.contentGroup = container.getParent()
      m.componentPool = componentPool
      m.owner = owner
      m.axes = axes
      m.minPos = minPos
      m.maxPos = maxPos
      m.lastScrollDirection = 0
      m.lastScrollIndex = 0

      m.updateScreenRect()
    end function

    protected function updateScreenRect()
      'bs:disable-next-line
      bounds = m.owner.sceneBoundingRect()
      m.screenRect = { translation: [bounds.x, bounds.y], size: [m.owner.width, m.owner.height] }
    end function

    public function reset()
      m.log.info ("resetting base.itemViewManager", m.__classname)
      ' ? "RESETTING VIEW MANAGER "; m.__classname

      m.content = invalid
      m.rects = []
      m.settings = invalid

      m.direction = 0
      m.visibleItems = []
      m.numberOfItems = 0
      m.numberOfVisibleItems = 0

      m.lastRenderedIndexes = { startIndex: -1, endIndex: -1 }
      m.lastScrollIndex = 0
      m.lastScrollDirection = 0
      m.renderedComponents = []
      m.isScrolling = false
      m.scrollingStartIndex = -1
      m.isRendering = false

      m.lastScrollEvent = invalid
      m.itemScroller.reset()
    end function

    function forceUpdateLayout()
      m._updateLayout()
    end function

    function setContent(content as types.node)
      m.log.info("setContent")
      m.content = content
      m.settings = list.listMixin.getRowSettings(m.owner.content, m.content)
      m.listSettings = m.owner.content.listSettings
      ' m.container.removeChildren(m.container.getChildren(-1, 1))
      if m._createRenderers(content) = false
        m.isRendering = true
        m.log.info("This viewManager is doing async rendering")
      else
        m.onRenderersCreated()
      end if
    end function

    function _createRenderers(content as types.node) as boolean
      m.visibleItems = []

      return m.createRenderers(content)
    end function

    protected function onRenderersCreated()
      m.isRendering = false
      m._updateLayout()
    end function

    function _updateLayout()
      m.log.info("_updateLayout")
      m.updateScreenRect()
      m.updateLayout()
    end function

    function onFocusIndexChange(direction as integer, index as integer)
      m.updateRenderedComponents(direction, index)
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ util
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function convertChildTranslationToOwner(containerTranslation as types.array)
      return [m.container.translation[0] + containerTranslation[0], m.container.translation[1] + containerTranslation[1]]
    end function

    function convertOwnerTranslationToChild(ownerTranslation as types.array)
      return [m.container.translation[0] - ownerTranslation[0], m.container.translation[1] - ownerTranslation[1]]
    end function

    function getComponentsInViewPort(startOffset as integer)
      compStates = {}

      sStart = m.screenRect.translation[m.axes] + startOffset
      sEnd = sStart + m.screenRect.size[m.axes]

      for each item in m.visibleItems
        comp = m.renderersByContentId[item.id]
        if comp <> invalid and comp.index <> invalid
          cRect = m.rects[comp.index]
          if cRect <> invalid
            cStart = cRect.translation[m.axes]
            cEnd = cStart + cRect.size[m.axes]
            if (cStart >= sStart and cStart <= sEnd) or (cEnd >= sStart and cEnd <= sEnd)
              compStates[comp.id] = true
            else
              compStates[comp.id] = false
            end if
            ' ? " LIST COMPS IN VP SS " ; sStart ; " SE" ; sEnd ; " CS " ; cStart ; " CE " ; cEnd
          end if
        else
          ' ? "comp index not set!"
        end if
        ' m.log.info(compStates[comp.id], "sStart", sStart, "sEnd", sENd, "cStart", cStart, "cEnd", cENd)
      end for

      ' ? " STATES " ; formatJson(compStates)
      return compStates
    end function

    function setIsScrolling(isScrolling as boolean, isLong as boolean, startIndex as integer)
      ' ? m.__classname ; " setIsScrolling " ; isScrolling

      m.isScrolling = isScrolling
      m.scrollingStartIndex = isScrolling ? startIndex: -1
      m.owner.isScrolling = isScrolling
      event = {
        name: isScrolling ? "scrollStart" : "scrollStop"
        startIndex: m.scrollingStartIndex
        long: isLong
        startIndex: m.scrollingStartIndex
      }
      m.lastScrollEvent = isScrolling ? event : invalid

      for each comp in m.renderedComponents
        comp.listEvent = event
      end for
    end function

    function updateScrolling(currentIndex as integer) as void
      if currentIndex = m.scrollingStartIndex or m.scrollingStartIndex = -1
        return
      end if
      m.lastScrollEvent = {
        name: "scrollUpdate"
        startIndex: m.scrollingStartIndex
        currentIndex: currentIndex
      }
      for each comp in m.renderedComponents
        comp.listEvent = m.lastScrollEvent
      end for
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ visibility state management
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function updateRenderedComponents(direction as integer, index as integer, force = false as boolean) as void
      ' ? ""
      ' ? ""
      ' ? "((((((((((((((((((((((((((((((((((((("
      ' ? "updateRenderedComponents " ; m.__classname
      if not force and not m.shouldUpdateRenderedIndexes(direction, index)
        ' ? "not updating rendered indexes - shouldUpdateRenderedIndexes: false"
        return
      end if

      renderedIndexes = m.getRenderedIndexes(direction, index)
      ' ? " ++++ renderedIndexes " ; renderedIndexes ; " I " ; index ; " D "; direction ; " " ; m.__classname

      if not force and (m.lastRenderedIndexes <> invalid) and m.lastRenderedIndexes.startIndex = renderedIndexes.startIndex and m.lastRenderedIndexes.endIndex = renderedIndexes.endIndex
        ' this is the same set of comps as last time
        if m.renderedComponents.count() > 0
          ' and we have seemingly done our initial render; so we can bail.
          ' ? "+++ initial RENDER DONE" ; m.__classname
          return
        end if
      end if
      ' ? "C " ; m.__classname ; formatJson(renderedIndexes)
      ' 'bs:disable-next-line
      m.log.info("+-renderedIndexes index", index, renderedIndexes)
      renderedStateMap = m.createRenderedStateMap(direction, index, renderedIndexes)
      m.renderedComponents = []
      ' ? "TUR ::: AFTER STATE MAP" ; m.__classname
      ' ? " " ; formatJson(renderedStateMap)
      m.applyRenderStateMap(renderedStateMap)

      m.tidyUpUnusedRenderers()
      m.lastRenderedIndexes = renderedIndexes
    end function

    protected function tidyUpUnusedRenderers() as void
      ' ? "Tidying up renderers " ; m.__classname
      removedRenderers = []
      ' ? " CONTAINER HAS " ; m.container.getChildCount() - 1 ; " RENS "
      for i = 1 to m.container.getChildCount() - 1
        renderer = m.container.getChild(i)
        if renderer.content = invalid
          removedRenderers.push(renderer)
        else if m.renderersByContentId[renderer.content.id] = invalid
          removedRenderers.push(renderer)
          renderer.content = invalid
        end if
      end for
      ' ? " cleaning up "; removedRenderers.count() " renderers"
      m.componentPool@.releaseComponents(removedRenderers)
    end function

    function shouldUpdateRenderedIndexes(direction as integer, index as integer)
      ' ? "???? I "; index ; " LI " ; m.lastScrollIndex ; " D " ; direction ; " LD " ; m.lastScrollDirection
      if direction <> m.lastScrollDirection or abs(index - m.lastScrollIndex) > m.renderedIndexUpdateInterval or index = 0
        ' ? " LIST SHOULD UPDATE I "; index ; " LI " ; m.lastScrollIndex ; " D " ; direction ; " LD " ; m.lastScrollDirection
        m.lastScrollIndex = index
        m.lastScrollDirection = direction
        return true
      end if
      return false
    end function

    function getRenderedIndexes(direction as integer, index as integer) as types.assocarray
      'TODO - upgrade to use componentInfos
      info = m.cellInfos[index]
      if info = invalid
        return {
          startIndex: -1
          endIndex: -1
        }
      end if
      indexPos = abs(info.getScrollOffset(direction))

      if direction < 0
        beforePos = indexPos - m.lookAheadDistance
        afterPos = indexPos + m.lookBehindDistance
      else
        afterPos = indexPos + m.lookAheadDistance
        beforePos = indexPos - m.lookBehindDistance
      end if

      if beforePos < 0
        beforePos = 0
      end if

      if afterPos < 0
        afterPos = 0
      end if

      ' 'bs:disable-next-line
      indexes = {
        startIndex: m.getIndexAtPosition(beforePos, direction)
        endIndex: m.getIndexAtPosition(afterPos, direction)
      }

      'couple of hacky fixes - need to work out how it get's in this state
      if indexes.startIndex = indexes.endIndex and indexes.startIndex = 0
        indexes.endIndex = 1
      end if
      if indexes.startIndex = indexes.endIndex and indexes.startIndex = 1
        indexes.startIndex = 0
      end if
      ' ? formatJson(indexes)
      return indexes
    end function

    function createRenderedStateMap(direction as integer, index as integer, renderedIndexes as integer)
      m.log.method("createRenderedStateMap", m.__className, index, renderedIndexes)
      renderedStateMap = {}

      ' ?  ">>>>> CRSM "; m.numberOfItems ; " " ; m.__classname
      if m.numberOfItems = 0
        return {}
      end if

      ' ? "++++++++++++++++++++"
      ' ? "LRI> " ; m.lastRenderedIndexes ; " " ; m.__classname
      m.updateRenderStateMap(renderedStateMap, m.lastRenderedIndexes.startIndex, m.lastRenderedIndexes.endIndex, m.componentBufferMode)
      m.updateRenderStateMap(renderedStateMap, renderedIndexes.startIndex, renderedIndexes.endIndex, "rendered")
      return renderedStateMap
    end function

    function updateRenderStateMap(renderedStateMap as types.assocarray, startIndex as integer, endIndex as integer, state as string)
      if startIndex < 0
        startIndex = 0
      end if

      ' ? " endindex " ; endIndex ; " m.numberOfItems "; m.numberOfItems
      if endIndex > m.numberOfItems
        endIndex = m.numberOfItems - 1
      end if

      for i = startIndex to endIndex

        rect = m.rects[i]
        if rect <> invalid
          ' ? "ROW "; i ; " rect idx "; rect.index ; " state " ; state
          renderedStateMap[str(rect.index).trim()] = state
        else
          ' ? " NO RECT "; i
        end if
      end for
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ itemRect positions
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function getFlowScreenPosition(index as integer, direction as integer)
      itemRect = m.rects[index]

      if itemRect = invalid
        m.log.warn("no itemRect for index", index)
        return invalid
      end if

      itemScreenPos = m.container.translation[m.axes] + itemRect.translation[m.axes]

      ' ? "GFSP I " ; index ; " ao: "; m.itemScroller.activeOffset ; " pos " ; itemScreenPos
      if itemScreenPos >= m.minPos and itemScreenPos + itemRect.size[m.axes] <= m.maxPos
        'we can simply move the focus to this position
        return itemScreenPos
      end if

      'if part or all of the view is off the viewport, then a scroll is required
      return invalid
    end function

    function getOffsetForScreenPosition(itemRect as object, screenPos as integer)
      if itemRect <> invalid
        return itemRect.translation[m.axes] - screenPos
      else
        return m.minPos
      end if
    end function

    function getIndexAtPosition(position as integer, direction as integer)
      p = abs(position)
      i = 0
      for i = 0 to m.cellInfos.count() - 1
        info = m.cellInfos[i]
        'the offset is already factored in
        itemPos = abs(info.getScrollOffset(direction))
        ' ? "i "; i ; "pos"; position ; " p "; p ; " ip " ; itemPos
        if itemPos > p
          ' ? "+++++!!! MATCHED ITEM INDEX "; i - skipped
          return clamp(i - 1, 0, m.numberOfItems - 1)
        end if
      end for
      ' end ifk

      'we must be at the end! -return last item
      index = clamp(i - 1, 0, m.numberOfItems - 1)
      ' ? "+++++!!! MATCHED ITEM INDEX "; index
      return index
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ general item api
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function getRect(index as integer, useScreenCoords = false as boolean)
      rect = m.rects[index]

      if rect <> invalid
        screenRect = {
          size: [rect.size[0], rect.size[1]]
          translation: [rect.translation[0], rect.translation[1]]
          index: rect.index
          screenPos: rect.screenPos
        }
        if useScreenCoords
          screenRect.translation = m.convertChildTranslationToOwner(screenRect.translation)
        end if
      else
        screenRect = {
          translation: [0, 0]
          size: [0, 0]
          index: -1
          screenpos: 0
        }
      end if
      return screenRect
    end function

    function getFocusSettings()
      if m.settings <> invalid
        return m.settings.focusSettings
      else
        return invalid
      end if
    end function

    function getItemSettings()
      return m.settings
    end function

    function getItemSize(index as integer) as types.array
      itemRect = m.rects[index]
      if itemRect <> invalid
        return itemRect.size
      else
        return [0, 0]
      end if
    end function

    function getIsOnScreen(info as list.componentInfo, screenPos = 0 as integer) as boolean
      rect = m.rects[info.contentIndex]
      if rect = invalid
        return false
      end if
      if info.component = invalid
        'TODO - this is wrong - a component might not yet be rendered..
        info.component = m.getRenderer(info.index)
        if info.component = invalid
          ? " could not get renderer for this info"
          return false
        end if
      end if
      'bs:disable-next-line
      bounds = info.component.sceneBoundingRect()
      w = rect.size[0]
      h = rect.size[1]
      translation = [bounds.x, bounds.y]
      translation[m.axes] += screenPos
      return translation[0] >= m.screenRect.translation[0] and translation[0] + w <= m.screenRect.size[0] and translation[1] >= m.screenRect.translation[1] and translation[1] + h <= m.screenRect.size[1]
    end function
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ abstract methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function isFlowFocusPossible(info as list.componentInfo, direction as integer, activeScreenPos as integer)
      isFlowPossible = info.isFlowFocusPossible(m.container.translation[m.axes], m.maxPos, direction, m.axes)

      if not isFlowPossible and info.isFlowFocusAllowed
        'check on the renderer
        ' ? "Flow not possible based on component info - checking actual component " ; m.screenPos ; " NI "; info.index
        isFlowPossible = m.getIsOnScreen(info, activeScreenPos)
      end if
      return isFlowPossible
    end function

    function isVerticalFlowFocusPossible(info as list.componentInfo, direction as integer, activeScreenPos as integer)
      return true
    end function

    function createRenderers(content as types.node, forceSync = false as boolean) as boolean
      m.log.error("You must override this method")
      return false
    end function

    function updateLayout()
      m.log.error("You must override this method")
    end function

    function applyRenderStateMap(renderedStateMap as types.assocarray)
      m.log.error("You must override this method")
    end function

    function getRenderer(index as integer)
      m.log.error("You must override this method")
      return invalid
    end function

    protected function onContentItemsChange(changes as types.array)
      'override me
    end function

    protected function getRowInfos(yOffset as integer, forceRecalculate = false as boolean) as types.array
      if forceRecalculate
        m.rowInfos = invalid
      end if

      if m.settings = invalid
        ? "+!!!!!?!! INVALID SETTINGS"
        return []
      end if
      if m.rowInfos = invalid
        focusSettings = m.getFocusSettings()

        screenPos = m.settings.screenPos
        positions = [
          new list.ComponentPosition(yOffset, screenPos) 'normal
          new list.ComponentPosition(yOffset, screenPos) 'float-scroll
        ]
        m.rowInfos = [new list.ComponentInfo([0, 0], focusSettings, positions, false, 0, 0)]
      end if
      return m.rowInfos
    end function

  end class
end namespace