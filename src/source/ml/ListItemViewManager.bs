import "pkg:/source/ml/ItemViewManager.bs"
import "pkg:/source/ml/ListMixin.bs"

namespace list
  class ListItemViewManager extends list.ItemViewManager

    private batchTimer as types.node
    private visibleComponents = []

    private isUpdating = false
    private previousFocusedRow as types.node
    private previousFocusedIndex = 0
    private isShowingAllComps = false
    ' public componentBufferMode = "rendered"
    public componentBufferMode = "none"

    public override function reset()
      m.log.info ("resetting viewManager. numItems: ", m.numberOfItems)

      if m.isRendering
        m.cancelBatching()
      end if

      if m.visibleComponents.count() > 0
        m.log.info("releasing", m.visibleComponents.count(), "list children")
        for each component in m.visibleComponents
          component.content = invalid
        end for
        m.componentPool@.releaseComponents(m.visibleComponents)
      end if
      m.renderersByContentId = {}

      super.reset()
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ async row creation
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    private creationIndex = -1
    'sometimes we want to create all rows up front, for important screens
    'using async renderer creation allows us to do this without clogging up the devices's render thread
    private batchSize = 3
    private batchDelay = 3

    function new(l as types.node, container as types.node, minPos as integer, maxPos as integer, componentPool as types.node)
      super("ListItemViewManager", l, container, componentPool, 1, minPos, maxPos)
      m.delegate = l.rowEvents
      m.lookAheadDistance = maxPos * 5
      m.lookBehindDistance = maxPos * 2
    end function

    override function getRenderer(index as integer)
      return m.visibleComponents[index]
    end function

    private function cancelBatching()
      m.isRendering = false
      m.isUpdating = false
      'ensure that we catch any components if we were half way through a batch, so we can remove them
      allComponents = {}
      m.visibleComponents = []
      allComponents.append(m.previousRendereredByContentId)
      allComponents.append(m.renderersByContentId)
      for each id in allComponents
        m.visibleComponents.push(allComponents[id])
      end for
      m.cancelWaitTimer(m.batchTimer)
    end function

    override function createRenderers(content as types.node, forceSync = false as boolean) as boolean

      ' ? "CREATE RENDERERS"
      m.visibleComponents = []
      m.visibleItems = []
      m.updateRects()
      if content <> invalid
        m.creationIndex = -1
        m.previousRendereredByContentId = m.renderersByContentId
        m.renderersByContentId = {}
        m.visibleComponents = []
        settings = content.listSettings
        if not forceSync and settings.rowCreationStrategy = "async" and not m.isUpdating
          m.batchSize = settings.rowCreationBatchSize
          m.batchDelay = settings.rowCreationBatchDelay
          m.owner.state = "rendering"
          isReady = false
          m.batchTimer = m.waitAFrame(m.createRendererBatch, 0.15)
        else
          ' ? "USING SYNC MODE"
          m.batchSize = m.content.getChildCount()
          isReady = true
        end if
        m.createRendererBatch()
        return isReady
      end if
      return false
    end function

    protected override function onRenderersCreated()
      super.onRenderersCreated()
      ' ? "TUR ::: LIST onRenderersCreated"
      m.tidyUpUnusedRenderers()
      if not m.isUpdating
        m.owner.state = "rendered"
        m.itemScroller.reset()
      else
        m.log.info("was updating, so not updating scroll position")
        'TODO - update the scrolling position if it was on a removed row
        m.isUpdating = false
      end if
      m.itemScroller.getComponentInfos(true)
      m.restorePreviousFocus()
    end function

    private function restorePreviousFocus()
      focusIndex = [0, 0]

      if m.previousFocusedRow <> invalid
        row = m.renderersByContentId[m.previousFocusedRow.id]
        if row = invalid
          index = m.previousFocusedIndex < m.numberOfItems ? m.previousFocusedIndex : m.numberOfItems - 1
          row = m.visibleComponents[index]
        end if

        if row <> invalid
          focusIndex[0] = row.index
          focusIndex[1] = row.focusedCellIndex
        end if
      end if
      m.previousFocusedIndex = 0
      m.previousFocusedRow = invalid
      ' 'TODO need to actually set the focus properly
      m.itemScroller.moveToIndex(focusIndex[0], false)
      ' m.itemScroller.forceFocusOnIndex(focusIndex[0])
    end function

    override function createRendererBatch() as void
      if m.content <> invalid
        index = 0
        for i = 0 to m.batchSize
          m.log.info(">>> BEGIN CREATE ROW", i)
          m.creationIndex++
          index = m.creationIndex
          if m.creationIndex >= m.content.getChildCount()
            ' ? "FINISHED RENDERING LIST ROWS"
            m.onRenderersCreated()
            return
          end if
          rowContent = m.content.getChild(index)
          settings = list.listMixin.getRowSettings(m.content, rowContent)
          rect = m.rects[index]

          comp = m.previousRendereredByContentId[rowContent.id]
          if comp <> invalid
            m.log.info("using comp for the same row")
            ' ? " REUSING COMP FOR SAME ROW "; index
            comp.index = index
            comp.translation = rect.translation
            m.previousRendereredByContentId.delete(rowContent.id)
            'TODO do I need to set renderState
          else
            m.log.info("creating row for this item")
            comp = m.createRow(rowContent, index, settings, rect)
          end if


          if comp <> invalid
            m.visibleComponents.push(comp)
            m.renderersByContentId[rowContent.id] = comp
          else
            m.log.error("could not create row for index ")
          end if
          m.visibleComponents.push(comp)
          index++
          m.log.info(">>> END CREATE ROW", i)
        end for
        if m.creationIndex < m.content.getChildCount()
          m.waitAFrame(m.createRendererBatch, 0.15)
        end if
      end if
    end function

    function createRow(rowContent as types.node, index as integer, settings as types.node, rect as types.assocarray)
      compName = settings.componentName <> invalid ? settings.componentName : "ml_HorizontalRow"
      'TODO - measure height to ascertain how many
      isRendered = index < 4
      ' isRendered = true
      row = m.componentPool@.getComponent(compName, 1)
      m.renderersByContentId[rowContent.id] = row

      row.setFields(rect)

      state = {
        renderState: isRendered ? "rendered" : m.componentBufferMode
        isRendered: isRendered
        owner: m.owner
        width: m.owner.width
        isInViewport: isRendered
      }
      row.setFields(state)
      m.container.appendChild(row)

      if row.isInitialized
        ' ? "RECYCLE EXISTING ROW"
        row@.recycle(rowContent)
        row.content = rowContent
      else
        ' ? "CREATE NEW ROW "
        row.content = rowContent
        row@._initialize(invalid)
      end if

      return row
    end function

    override function updateLayout()
      m.updateRects()
      for i = 0 to m.rects.count() - 1
        rect = m.rects[i]
        comp = m.visibleComponents[i]
        if comp <> invalid
          comp.translation = rect.translation
          comp.visible = rect.visible
        end if
      end for
    end function

    override function updateRects() as void
      y = 0
      w = m.owner.width
      m.rects = []
      m.visibleItems = []
      m.visibleComponents = []

      if m.content = invalid
        return
      end if

      for i = 0 to m.content.getChildCount() - 1
        item = m.content.getChild(i)
        settings = list.listMixin.getRowSettings(m.content, item)
        visible = item.isHidden <> true and (not settings.isHiddenWhenEmpty or item.length > 0)
        ' ? "ITEM " ; i ; " VISIBLE "; visible ; " L "; item.length ; " " ; item.getChildCount() ; " isHidden " ; item.isHidden
        if visible
          if settings.subType() = "ml_GridRowSettings"
            height = m.calculateGridRowHeight(item, settings)
          else
            height = m.calculateRowHeight(settings)
          end if
          screenPos = settings.screenPos

          translation = [0, y]
          yOffset = 0
          contentOffset = settings.contentOffset
          if contentOffset <> invalid
            translation[0] += contentOffset[0]
            yOffset = contentOffset[1]
            translation[1] += yOffset
          end if

          height += settings.space + yOffset
          if settings.peekNextPixels <> 0
            screenPos = 1080 - (height + settings.peekNextPixels)
            settings.screenPos = screenPos
          end if

          y += height
        else
          height = 0
          screenPos = 0
          translation = [0, 0]
        end if

        m.visibleItems.push(item)
        m.rects.push({
          translation: translation
          size: [w, height]
          index: i
          screenPos: screenPos
          visible: visible
        })
        comp = m.renderersByContentId[item.id]
        if comp <> invalid
          if comp.height = 0 or comp.height = -1
            comp.height = height
          end if
          m.visibleComponents.push(comp)
        end if
      end for

      m.numberOfItems = m.visibleItems.count()
      m.numberOfVisibleItems = m.visibleComponents.count()
    end function

    override function applyRenderStateMap(renderStateMap as types.assocarray)
      ' ? " APPLYING STATE MAP " ; formatJson(renderStateMap)
      for each id in renderStateMap
        comp = m.visibleComponents[id.toInt()]

        if comp <> invalid and comp.renderState <> renderStateMap[id]
          comp.renderState = renderStateMap[id]
          if comp.renderState = "rendered"
            m.renderedComponents.push(comp)
          end if
          comp.isRendered = comp.renderState = "rendered"
          ' ? " set comp.isRendered "; comp.isRendered
        else
          ? "ERROR could not find visible comp for "; id
        end if
      end for

    end function

    override function getFocusSettings()
      return m.content.focusSettings
    end function

    ' @params{ml_RowSettings} settings for the current row
    private function calculateRowHeight(settings as types.node) as integer
      height = 300
      if settings = invalid
        return height
      end if

      if settings.height <> -1
        height = settings.height
      else if settings.cellSettings <> invalid
        height = settings.cellSettings.size[1]
      end if

      if settings.headerSettings.position <> "none"
        height += settings.headerSettings.height
      end if
      return height
    end function

    private function calculateGridRowHeight(row as types.node, settings as types.node) as integer
      numItems = row.getChildCount()
      numCols = settings.numColumns
      numCols = numCols < 1 ? 1 : numCols
      numRows = divideNumberToNearest(numItems, numCols)
      rowHeight = settings.rowHeight + settings.rowSpace
      height = numRows * rowHeight

      ' ? "+>+>+ GRID HEIGHT "; numItems ; "/" numCols ; " NR "; numRows ; " height " ; height
      if settings.headerSettings.position <> "none"
        height += settings.headerSettings.height
      end if
      return height
    end function

    protected override function onContentItemsChange(changes as types.array)
      m.log.info("updating row renderers due to contents change")
      m.isUpdating = true
      m.previousFocusedRow = m.itemScroller.focusedItem
      m.previousFocusedIndex = m.itemScroller.index
      ' ? " GOT CHANGES "; formatJson(collections.map(changes, function(c as object)
      '   return c.type
      ' end function))
      m.createRenderers(m.content)
      m.itemScroller.processChanges(changes)
      m.itemScroller.move(0)
    end function

    override function isFlowFocusPossible(info as list.componentInfo, direction as integer, activeScreenPos as integer)


      if info <> invalid and info.component <> invalid and info.component.subType() = "ml_GridRow"

        isFlowPossible = info.component@.isVerticalFlowFocusPossible(info, direction, activeScreenPos, m.container.translation[m.axes])
        ' ? "L>>>>>> GRID ROW " ; info.index ; " D " ; direction ; isFlowPossible
      else
        isFlowPossible = info.isFlowFocusPossible(m.container.translation[m.axes], m.maxPos, direction, m.axes)
      end if

      if not isFlowPossible and info.isFlowFocusAllowed
        'check on the renderer
        ' ? "Flow not possible based on component info - checking actual component " ; m.screenPos ; " NI "; info.index
        ' isFlowPossible = m.getIsOnScreen(info, activeScreenPos)
        isFlowPossible = m.getIsOnScreen(info, 0)
      end if
      ' end if

      return isFlowPossible
    end function

    public function getItemInfoForIndex(rowIndex as integer, cellIndex as integer)

    end function


    override function getRenderedIndexes(direction as integer, index as integer) as types.assocarray
      'TODO - upgrade to use componentInfos

      info = invalid

      if m.itemScroller.componentInfos <> invalid
        if index >= m.itemScroller.componentInfos.count()
          index = m.itemScroller.componentInfos.count() - 1
        end if
        if m.listSettings.lookAheadDistance = -1
          ' ? " list is rendering everything" ; m.itemScroller.componentInfos.count()
          return {
            startIndex: 0
            endIndex: m.itemScroller.componentInfos.count()
          }
        end if
        info = m.itemScroller.componentInfos[index]
      end if

      if info = invalid
        ' ? " LIST HAS NO componentInfos CANNOT RENDER ANYTHING" ; index
        return {
          startIndex: -1
          endIndex: -1
        }
      end if
      indexPos = abs(info.getScrollOffset(direction))

      if direction < 0
        beforePos = indexPos - m.lookAheadDistance
        afterPos = indexPos + m.lookBehindDistance
      else
        afterPos = indexPos + m.lookAheadDistance
        beforePos = indexPos - m.lookBehindDistance
      end if

      if beforePos < 0
        beforePos = 0
      end if

      if afterPos < 0
        afterPos = 0
      end if

      'NOTE THERE IS AN ISSUE WHERE TWO VIEWS ARE AT THE SAME POS WITH DIFFERENT SCREEN OFFSETS
      ' 'bs:disable-next-line
      indexes = {
        startIndex: m.getIndexAtPosition(beforePos, direction) - 1
        endIndex: m.getIndexAtPosition(afterPos, direction) + 1
      }
      ' ? " before Pos" ; beforePos
      ' ? " after Pos" ; afterPos
      ' ? "COMP COUNT" ; m.itemScroller.componentInfos.count()
      ' indexes = {
      '   startIndex: m.itemScroller.index - 3
      '   endIndex: m.itemScroller.index + 5
      ' }

      'couple of hacky fixes - need to work out how it get's in this state
      if indexes.startIndex = indexes.endIndex and indexes.startIndex = 0
        indexes.endIndex = 1
      end if
      if indexes.startIndex = indexes.endIndex and indexes.startIndex = 1
        indexes.startIndex = 0
      end if
      ' ? "LIST LIST LIST"
      ' ? formatJson(indexes)
      return indexes
    end function


    override function getIndexAtPosition(position as integer, direction as integer)
      p = abs(position)
      i = 0
      for i = 0 to m.itemScroller.componentInfos.count() - 1
        info = m.itemScroller.componentInfos[i]
        'the offset is already factored in
        itemPos = abs(info.getPosition(direction))
        ' itemPos = abs(info.getScrollOffset(direction))
        ' ? "i "; i ; " pos"; position ; " p "; p ; " ip " ; itemPos ; " INFO " ; info.index ; " c " ; dv(info.component)
        if itemPos > p
          ' ? "+++++!!! MATCHED ITEM INDEX "; i - 1
          return clamp(i - 1, 0, m.numberOfItems - 1)
        end if
      end for
      ' end ifk

      'we must be at the end! -return last item
      index = clamp(i - 1, 0, m.numberOfItems - 1)
      ' ? "+++++!!! MATCHED ITEM INDEX "; index
      return index
    end function

  end class
end namespace