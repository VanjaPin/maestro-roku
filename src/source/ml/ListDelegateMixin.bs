namespace list.delegateMixin

  ' @param {MList} list instance to add delegate methods for
  ' @param {class} instance, target for the delegate methods - if invalid, then methods will be called on m
  ' @returns {returnType} returnDescription
  function setListDelegate(l as types.node, instance = invalid as object)
    if instance = invalid
      instance = m
    end if

    l.delegateMixin.setListRowDelegate(l, instance)
    l.delegateMixin.setListCellDelegate(l, instance)
    l.delegateMixin.setListDelegate_internal(l, instance)

    if m.isObservingCellEvents or m.isObservingRowEvents or m.isObservingListEvents
      m.listDelegate = instance
    else
      m.listDelegate = invalid
    end if

    ' ? "SET LIST DELEGATE: CE "; m.isObservingCellEvents ; " RE " ; m.isObservingRowEvents
    list.delegateMixin.toggleDelegateActive(list)

  end function

  function toggleDelegateActive(l as types.node)
    if m.isObservingCellEvents
      ' ? "LISTENING TO CELL EVENTS"
      toggleObserver(l.cellEvents, "listEvent", getFunctionName(list.delegateMixin.onCellEventBridge))
      toggleObserver(l.cellEvents, "viewportEvents", getFunctionName(list.delegateMixin.onCellEventsBridge))
    else
      toggleObserver(l.cellEvents, "listEvent")
      toggleObserver(l.cellEvents, "viewportEvents")

    end if

    if m.isObservingRowEvents
      ' ? "LISTENING TO ROW EVENTS"
      toggleObserver(l.rowEvents, "listEvent", getFunctionName(list.delegateMixin.onRowEventBridge))
      toggleObserver(l.rowEvents, "viewportEvents", getFunctionName(list.delegateMixin.onRowEventsBridge))
    else
      toggleObserver(l.rowEvents, "listEvent")
      toggleObserver(l.rowEvents, "viewportEvents")
    end if

    if m.isObservingListEvents
      ' ? "LISTENING TO ROW EVENTS"
      toggleObserver(l, "listEvent", getFunctionName(list.delegateMixin.onListEventBridge))
    else
      toggleObserver(l, "listEvent")
    end if
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ cells
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  function setListCellDelegate(l as types.node, instance = invalid as object)
    m.listCellEventMap = {}

    if instance <> invalid
      funcMap = {
        "onCellWillEnter": "willEnter"
        "onCellWillExit": "willExit"
        "onCellDidEnter": "didEnter"
        "onCellDidExit": "didExit"
        "onCellWillGainFocus": "willGainFocus"
        "onCellWillLoseFocus": "willLoseFocus"
        "onCellDidGainFocus": "didGainFocus"
        "onCellDidLoseFocus": "didLoseFocus"
        "onCellGainingFocus": "gainingFocus"
        "onCellLosingFocus": "losingFocus"
      }

      for each funcName in funcMap
        if isFunction(instance[funcName])
          m.listCellEventMap[funcMap[funcName]] = funcName
        end if
      end for
    end if

    m.isObservingCellEvents = m.listCellEventMap.count() > 0
  end function

  function onCellEventBridge(sgEvent as object) as void
    if m.isObservingCellEvents
      list.delegateMixin.handleCellEvent(sgEvent.getData())
    end if
  end function

  function onCellEventsBridge(sgEvent as object) as void
    if m.isObservingCellEvents
      for each event in sgEvent.getData()
        list.delegateMixin.handleCellEvent(event)
      end for
    end if
  end function

  function handleCellEvent(event as types.assocarray) as void
    eventName = event.name
    if not m.isObservingCellEvents or m.listCellEventMap[eventName] = invalid
      ' ? "LE(skipped) " ; eventName ; " " ; event.direction ; " I " ; "" ; event.index ; " " ; event.fraction
      return
    end if
    ' ? "onListEventBridge OBSERVED " ; eventName

    if eventName = "gainingFocus" or eventName = "losingFocus"
      m[m.listCellEventMap[eventName]](event.rowIndex, event.index, event.direction, event.fraction)
    else
      m[m.listCellEventMap[eventName]](event.rowIndex, event.index, event.direction)
    end if

  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ list
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  function setListDelegate_internal(l as types.node, instance = invalid as object)
    m.listEventMap = {}

    if instance <> invalid
      funcMap = {
        "onItemSelected": "itemSelected"
      }

      for each funcName in funcMap
        if isFunction(instance[funcName])
          m.listEventMap[funcMap[funcName]] = funcName
        end if
      end for
    end if

    m.isObservingListEvents = m.listEventMap.count() > 0
  end function

  function onListEventBridge(sgEvent as object) as void
    if m.isObservingListEvents
      list.delegateMixin.handleListEvent(sgEvent.getData())
    end if
  end function

  function onListEventsBridge(sgEvent as object) as void
    if m.isObservingListEvents
      for each event in sgEvent.getData()
        list.delegateMixin.handleRowEvent(event)
      end for
    end if
  end function

  function handleListEvent(event as types.assocarray) as void
    eventName = event.name
    if not m.isObservingRowEvents or m.listRowEventMap[eventName] = invalid
      ' ? "LE(skipped) " ; eventName ; " " ; event.direction ; " I " ; "" ; event.index ; " " ; event.fraction
      return
    end if

    if eventName = "itemSelected"
      m.listDelegate.onItemSelected(event.index, event.cellIndex)
    end if

  end function


  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ rows
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  function setListRowDelegate(l as types.node, instance = invalid as object)
    m.listRowEventMap = {}

    if instance <> invalid
      funcMap = {
        "onRowWillEnter": "willEnter"
        "onRowWillExit": "willExit"
        "onRowDidEnter": "didEnter"
        "onRowDidExit": "didExit"
        "onRowWillGainFocus": "willGainFocus"
        "onRowWillLoseFocus": "willLoseFocus"
        "onRowDidGainFocus": "didGainFocus"
        "onRowDidLoseFocus": "didLoseFocus"
        "onRowGainingFocus": "gainingFocus"
        "onRowLosingFocus": "losingFocus"
        "onItemSelected": "itemSelected"
        "onScrollingUpdate": "scrollUpdate"
        "onScrollingUpdate": "scrollUpdate"
      }

      for each funcName in funcMap
        if isFunction(instance[funcName])
          m.listRowEventMap[funcMap[funcName]] = funcName
        end if
        if isFunction(instance["onRowScrollingChange"])
          m.listEventMap["scrollStart"] = "onRowScrollingChange"
          m.listEventMap["scrollStop"] = "onRowScrollingChange"
        end if

      end for
    end if

    m.isObservingRowEvents = m.listRowEventMap.count() > 0
  end function

  function onRowEventBridge(sgEvent as object) as void
    if m.isObservingRowEvents
      list.delegateMixin.handleRowEvent(sgEvent.getData())
    end if
  end function

  function onRowEventsBridge(sgEvent as object) as void
    if m.isObservingRowEvents
      for each event in sgEvent.getData()
        list.delegateMixin.handleRowEvent(event)
      end for
    end if
  end function

  function handleRowEvent(event as types.assocarray) as void
    eventName = event.name
    if not m.isObservingRowEvents or m.listRowEventMap[eventName] = invalid
      ' ? "LE(skipped) " ; eventName ; " " ; event.direction ; " I " ; "" ; event.index ; " " ; event.fraction
      return
    end if

    ' ? "LE  " ; eventName ; " " ; event.direction ; " I " ; "" ; event.index ; " " ; event.fraction
    if eventName = "scrollStart" or eventName = "scrollStop"
      m.listItemDelegate.onRowScrollingChange(event.index, eventName = "scrollStart", event.long)
    else if eventName = "scrollUpdate"
      m.listItemDelegate.onRowScrollingUpdate(event.startIndex, event.currentIndex)
    else if eventName = "gainingFocus" or eventName = "losingFocus"
      m.listDelegate[m.listRowEventMap[eventName]](event.index, event.direction, event.fraction)
    else if eventName = "onItemSelected"
      m.listDelegate.onItemSelected(event.index, event.cellIndex)
    else
      m.listDelegate[m.listRowEventMap[eventName]](event.index, event.direction)
    end if

  end function

end namespace