import "pkg:/source/core/Utils.bs"
import "pkg:/source/roku_modules/log/LogMixin.brs"

namespace view
  function findNodes(nodeIds as types.array) as void
    if type(nodeIds) = "roArray"
      for each nodeId in nodeIds
        node = m.top.findNode(nodeId)
        if node <> invalid
          m[nodeId] = node
        else
          m.log.warn("could not find node with id {0}", nodeId)
        end if
      end for
    end if
  end function

  function getFirstParentWithType(node as types.node, parentType as string) as types.node
    currentNode = node

    while currentNode <> invalid

      if currentNode.subType() = parentType
        return currentNode
      end if

      currentNode = currentNode.getParent()
    end while
    return invalid
  end function

  function getFieldInParent(content as types.node, fieldName as string, maxIterations = 3 as integer, defaultValue = {} as dynamic) as dynamic
    currentNode = content
    value = invalid

    i = 0
    while currentNode <> invalid and i < maxIterations
      value = currentNode[fieldName]
      if value <> invalid
        return value
      end if
      currentNode = currentNode.getParent()
      i++
    end while

    return defaultValue
  end function

  function destroyView(v as types.node)
    p = view.getParent()

    if p <> invalid
      p.removeChild(v)
    end if
  end function

  function createViewsFromStyleJson(childrenJson as types.array, targetNode as types.node, assignViewsToM = true as boolean, mTarget = invalid as types.assocarray)
    if mTarget = invalid
      mTarget = m
    end if

    'TODO - convert this to use update api, for speed.
    if isArray(childrenJson)
      if type(targetNode) = "roSGNode"
        for i = 0 to childrenJson.count() - 1
          nodeJson = childrenJson[i]

          nodeType = nodeJson._type
          if nodeType <> invalid
            children = nodeJson._children
            id = nodeJson.id
            nodeJson.delete("id")
            nodeJson.delete("_type")
            nodeJson.delete("_children")
            v = createSGNode(nodeType, targetNode, id, nodeJson, true, mTarget)
            if v <> invalid
              if children <> invalid
                view.createViewsFromStyleJson(children, v, assignViewsToM, mTarget)
              end if
              if assignViewsToM and id <> invalid
                if not mTarget.doesExist(id)
                  m.log.error("CREATE VIEW FROM STYLE JSON: Target view did not have field declared for id", id)
                else if mTarget[id] <> invalid
                  m.log.error("CREATE VIEW FROM STYLE JSON: Target view already had a view set for id", id)
                end if
                mTarget[id] = v
              end if
            else
              m.log.error("CREATE VIEW FROM STYLE JSON: Could not create view ", id, "with type", nodeType)
            end if
          end if
        end for
      else
        m.log.error("CREATE VIEW FROM STYLE JSON: Could not create views from style Json: Target node was invalid")
      end if
    else
      m.log.error("CREATE VIEW FROM STYLE JSON: Could not create view in targetNode", dv(targetNode), "json was invalid")
    end if
  end function

  ' assumes that all views exist on m, with the ids as described in childrenJson
  function updateViewsWithStyleJson(json as types.array, mTarget = invalid as types.assocarray)
    if mTarget = invalid
      mTarget = m
    end if

    if isAACompatible(json)
      for each id in json
        nodeJson = json[id]
        if isAACompatible(nodeJson)
          node = mTarget[id]
          if node <> invalid
            node.setFields(nodeJson)
          else
            m.log.error("could not find node with ", id, "on ", getPath(mTarget, "__classname", "UNKNOWN CLASS"))
          end if
        else
          m.log.error("found illegal json with style id ", id)
        end if
      end for
    else
      m.log.error("could not apply style json in ", getPath(mTarget, "__className", "UNKNOWN CLASS"), "json was invalid - expect key pairs for views that already exist on m")
    end if
  end function
end namespace