import "pkg:/source/core/Utils.bs"

namespace collections

  ' @description returns an array with items mapped by the mapper
  ' @param {array} array of items to map
  ' @param {class} mapper, function (transform):outputType, or class with a transform(item):outputType function
  ' @returns {outputType} items mapped by the mapper
  '  */
  function map(array as types.array, mapper as collections.BaseMapper)
    items = []
    if array <> invalid
      isClazz = isClass(mapper)
      for each item in array
        if isClazz
          transformed = mapper.transform(item)
          if transformed <> invalid
            items.push(transformed)
          end if
        else
          transformed = mapper(item)
          if transformed <> invalid
            items.push(transformed)
          end if
        end if
      end for
    end if
    return items
  end function

  function getSortedArrayByKey(arr as types.array, keyName as string, ascending = true as boolean) as types.array
    res = []
    if isArray(arr) and isString(keyName) and keyName <> ""
      dict = {}
      for each item in arr
        key = item[keyName]
        if isString(key)
          dict[key] = item
        end if
      end for
      keys = dict.keys()
      if not ascending
        keys.reverse()
      end if
      for each key in keys
        res.push(dict[key])
      end for
    end if
    return res
  end function

  function getSortedArrayByFunction(arr as types.array, func as function, ascending = true as boolean) as types.array
    res = []
    if isArray(arr) and isFunction(func)
      dict = {}
      for each item in arr
        key = func(item)
        if isString(key)
          dict[key] = item
        end if
      end for
      keys = dict.keys()
      if not ascending
        keys.reverse()
      end if
      for each key in keys
        res.push(dict[key])
      end for
    end if
    return res
  end function

  function getSortedArrayByCallFunc(arr as types.array, funcName as string, ascending = true as boolean) as types.array
    res = []
    if isArray(arr) and isString(funcName)
      dict = {}
      for each item in arr
        key = item.callFunc(funcName)
        if isString(key)
          dict[key] = item
        end if
      end for
      keys = dict.keys()
      if not ascending
        keys.reverse()
      end if
      for each key in keys
        res.push(dict[key])
      end for
    end if
    return res
  end function

  function getItemAtOffset(array as types.array, item as dynamic, offset as integer, key = invalid as string)
    if array = invalid or array.count() = 0
      return invalid
    end if
    index = collections.getArrayIndex(array, item, key)
    return array[clamp(index + offset, 0, array.count() - 1)]
  end function

  function getArrayIndex(array as types.array, item as dynamic, key = invalid as string)
    if array = invalid or array.count() = 0
      return -1
    end if

    itemKey = invalid
    isNode = false
    if key <> invalid
      if item <> invalid
        itemKey = item[key]
      else
        return -1
      end if
    else if type(item) = "roAssociativeArray"
      'use id as default key
      key = "id"
      itemKey = item[key]
    else if type(item) = "roSGNode"
      isNode = true
    end if

    for i = 0 to array.count() - 1
      if isNode
        if item.isSamenode(array[i])
          return i
        end if
      else if itemKey <> invalid
        if array[i] <> invalid and array[i][key] = itemKey
          return i
        end if
      else if array[i] = item
        return i
      end if
    end for
    return -1
  end function


  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ mappers
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  class BaseMapper
    function transform(item as dynamic)
    end function
  end class

  class CallFuncMapper extends collections.BaseMapper
    private funcName as string
    private args as types.assocarray

    function new(funcName as string, args as types.assocarray)
      super()
      m.funcName = funcName
      m.args = args
    end function

    override function transform(item as dynamic)
      if item = invalid
        return invalid
      end if
      return item.callFunc(m.funcName, m.args)
    end function
  end class

  class FuncMapper extends collections.BaseMapper
    private funcName as string

    function new(funcName as string)
      super()
      m.funcName = funcName
    end function

    override function transform(item as dynamic)
      if item = invalid
        return invalid
      end if
      if item[m.funcName] = invalid
        return invalid
      end if
      return item[m.funcName]()
    end function
  end class

  class FieldMapper extends collections.BaseMapper
    private fieldName as string

    function new(fieldName as string)
      super()
      m.fieldName = fieldName
    end function

    override function transform(item as dynamic)
      if item = invalid
        return invalid
      end if
      return item[m.fieldName]
    end function
  end class

  ' @param {array} array of items to filter
  ' @param {class} predicate, function (item):bool, or class with a isMatch(item):bool function
  ' @returns {boolean} items that match the predicate
  function filter(array as types.array, predicate as dynamic)
    items = []
    if array <> invalid
      isClazz = isClass(predicate)
      for each item in array
        if (isClazz and predicate.isMatch(item)) or (not isClazz and predicate(item))
          items.push(item)
        end if
      end for
    end if
    return items
  end function

  ' @param {array} array of items to filter
  ' @param {class} predicate, function (item):bool, or class with a isMatch(item):bool function
  ' @returns {boolean} returns the first item that matches, or invalid
  function find(array as types.array, predicate as dynamic)
    items = collections.filter(array, predicate)
    if items.count() = 0
      return invalid
    else
      return items[0]
    end if
  end function

  ' @param {array} array of items to filter
  ' @param {class} predicate, function (item):bool, or class with a isMatch(item):bool function
  ' @returns {boolean} returns true if the array matches the predicate
  function contains(array as types.array, predicate as dynamic) as boolean
    items = collections.filter(array, predicate)
    return items.count() > 0
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ filter predicates
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  class AbstractPredicate
    private expected as dynamic

    function isMatch(expected as dynamic) as boolean
      return false
    end function
  end class

  class ValuePredicate extends collections.AbstractPredicate
    function new(expected as dynamic)
      super(expected)
    end function

    override function isMatch(item as dynamic) as boolean
      return item = m.expected
    end function
  end class

  class FieldPredicate extends collections.AbstractPredicate
    private fieldName as string

    function new(fieldName as string, expected as dynamic)
      super(expected)
      m.fieldName = fieldName
    end function

    override function isMatch(item as dynamic) as boolean
      if item = invalid
        return false
      end if
      return item[m.fieldName] = m.expected
    end function
  end class

  class FuncPredicate extends collections.AbstractPredicate
    private funcName as string

    function new(funcName as string, expected as dynamic)
      super(expected)
      m.funcName = funcName
    end function

    override function isMatch(item as dynamic) as boolean
      if item = invalid
        return false
      end if
      if item[m.funcName] = invalid
        return false
      end if
      compareTo = item[m.funcName]()
      return compareTo = m.expected
    end function
  end class

  class CallFuncPredicate extends collections.AbstractPredicate
    private funcName as string
    private args as types.assocarray

    function new(funcName as string, args as types.assocarray, expected as dynamic)
      super()
      m.funcName = funcName
      m.args = args
    end function

    override function isMatch(item as dynamic) as boolean
      if item = invalid
        return false
      end if
      compareTo = item.callFunc(m.funcName, m.args)
      return m.expected = compareTo
    end function
  end class

  function arrayContains(array as types.array, value as dynamic) as boolean
    return collections.getArrayIndex(array, value) <> -1
  end function

end namespace
