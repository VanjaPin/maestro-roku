import "pkg:/source/core/Utils.bs"
import "pkg:/source/view/NodeClass.bs"
import "pkg:/source/core/Command.bs"

namespace mc
  @node("mc_CommandSequence", "Group")
  class CommandSequence extends mv.NodeClass

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Events
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    public output as mc.types.AssocArray

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Public Fields
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    @observer("begin")
    public control as string = invalid

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Private Fields
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    private completedCommands = {}
    private runningCommands = {}
    private runningCommandsCount = 0
    private commands = {}
    private taskCommands = {}

    protected firstCommand as mc.SequentialCommand

    function new()
      super(mc.dv(m.top))
    end function

    private function begin()
      m.log.info("starting CommandSequence")

      m.firstCommand = new mc.SequentialCommand("First Command", m.createCommands())
      m.startCommand(m.firstCommand)
    end function

    protected function createCommands()
      m.log.error("override createCommands to create your command structure")
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Marker functions
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Loading command Management
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    protected function optionalCommand(condition as boolean, command as mc.Command)
      return condition ? command : invalid
    end function

    protected function startCommand(command as mc.Command) as void
      m.log.info("starting command", command.name)

      if m.completedCommands.doesExist(command.name) or m.runningCommands.doesExist(command.name)
        m.log.error("duplicate command name. Cannot proceed", command.name)
        m.failCommand(command, `Duplicate command name: ${command.name}`)
        return
      end if

      m.runningCommandsCount++
      m.runningCommands[command.name] = true
      m.completedCommands[command.name] = false
      m.taskCommands[command.name] = command

      try
        if (command.isParallel = true or command.isSequence = true) and command.commandCount = 0
          m.log.info("Parallel or sequential command, with no children:", command.name)
          m.finishCommand(command)

        else if command.isParallel = true
          m.log.info(`command ${command.name} is a parallel command - starting commands now`)
          m.startParallelCommands(command)

        else if command.isSequence = true
          m.log.info(`command ${command.name} is a sequential command - starting commands now`)
          m.startSequentialCommand(command)

        else if command.isTask = true
          task = m.createTask(command.taskName, command.taskArgs, m.onTaskCommandCallback, true, "both")
          if task <> invalid
            mc.setOrAddNodeField(task, "__commandName", command.name)
            if task.isWaitingResult = false
              m.log.info("this task command does not need to await the result to continue")
              m.finishCommand(command)
            end if
          else
            message = `Error executing command ${command.name} could not create task: ${command.taskName}`
            m.failCommand(command, message)
          end if
        else
          'bs:disable-next-line
          m.__cb = command.func
          'bs:disable-next-line
          m.__cb(command)
        end if
      catch error
        'bs:disable-next-line
        message = `Error executing command ${command.name} error was: ${formatJson(error)}`
        m.log.error(message)
        m.failCommand(command, message)
      end try
    end function

    private function onTaskCommandCallback(value as mc.Result, task as mc.types.node)
      command = m.taskCommands[task.__commandName]
      if command <> invalid
        m.taskCommands.delete(task.__commandName)

        if command.onComplete <> invalid
          updatedOk = mc.apply(command.onComplete, [value], m)
          isOk = asBoolean(updatedOk, asBoolean(value.isOk))
        else
          isOk = asBoolean(value.isOk)
        end if

        if command.isWaitingResult = false
          m.log.info("this command was already completed, previously")
        else
          if isOk or asBoolean(command.ignoreFailure)
            m.finishCommand(command)
          else
            m.failCommand(command, `commandTask failed with error ${value.message}`)
          end if
        end if
      else
        m.log.error("Missing command on task completion call back", task.__commandName)
      end if
    end function

    protected function finishCommand(command as mc.Command)

      m.completedCommands[command.name] = true
      m.runningCommands.delete(command.name)
      m.runningCommandsCount--
      m.log.info("Finished command", command.name, m.runningCommandsCount, "remaining: ", formatJson(m.runningCommands.keys()))

      if command.parentCommand <> invalid
        if command.parentCommand.isParallel = true
          m.finishParallelCommand(command)
        end if
        if command.parentCommand.isSequence = true
          m.finishSequentialCommand(command)
        end if

        if command.parentCommand.isFinished
          m.log.info("parent command is finished")
          m.finishCommand(command.parentCommand)
        end if
      end if

      if m.runningCommandsCount = 0
        m.log.info("finished sequence")
        m.output = { isOK: true }
      end if
    end function

    private function finishSequentialCommand(command as mc.Command)
      m.log.info("this command is a sequence, seeing if it has a next command")
      command.parentCommand.moveNext()
      if command.parentCommand.currentCommand <> invalid
        m.log.info("has next command", command.parentCommand.currentCommand.name, "starting it")
        m.startCommand(command.parentCommand.currentCommand)
      end if
    end function

    private function finishParallelCommand(command as mc.Command)
      m.log.info("this command is a parallel command, seeing if all commands are now finished")
      command.parentCommand.completeCommand(command)
    end function

    private function startSequentialCommand(command as mc.SequentialCommand)
      command.moveNext()
      if command.isFinished
        m.log.info("parent command is finished on very first task")
        m.finishCommand(command)
      else
        m.log.info("starting first command in sequence")
        m.startCommand(command.currentCommand)
      end if
    end function

    private function startParallelCommands(command as mc.ParallelCommand)
      for each c in command.childCommands
        if c <> invalid
          m.startCommand(c)
        end if
      end for
    end function

    protected function failCommand(command as mc.Command, message as string)
      m.log.error(`command ${command.name} failed with message: `, message)
      if command.ignoreFailure = true
        m.log.warn("Ignoring failure")
        m.finishCommand(command)
      else
        m.log.error("cannot continue from command failure")

        m.output = { isOK: false, message: message }
      end if
    end function

  end class
end namespace
