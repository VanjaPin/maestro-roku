import "pkg:/source/roku_modules/log/LogMixin.brs"
import "Serialization.bs"

class Registry

  private log = new log.Logger("Registry")
  '
  ' Read and deserialize to a native type
  public function read(sectionName as string, key as string) as dynamic
    sectionName = lcase(sectionName)
    key = lcase(key)
    section = createObject("roRegistrySection", sectionName)

    if section.exists(key)
      return parseJson(section.read(key))
    else
      return invalid
    end if
  end function

  public function write(sectionName as string, key as string, value as dynamic) as void
    sectionName = lcase(sectionName)
    key = lcase(key)
    reg = createObject("roRegistry")
    section = createObject("roRegistrySection", sectionName)
    section.write(key, formatJson(value))
    section.flush()
    reg.flush()
  end function


  public function delete(sectionName as string, key as string) as void
    sectionName = lcase(sectionName)
    key = lcase(key)
    section = createObject("roRegistrySection", sectionName)
    if section.exists(key)
      section.delete(key)
    end if
  end function

  public function readAll() as object
    reg = createObject("roRegistry")
    sections = reg.getSectionList()
    data = {}

    for each sectionName in sections
      section = createObject("roRegistrySection", sectionName)
      keys = section.getKeyList()
      sectionData = {}

      for each k in keys
        sectionData[k] = parseJson(section.read(k))
      end for
      data[sectionName] = sectionData
    end for

    return data
  end function

  public function writeAll(data as object) as void
    reg = createObject("roRegistry")

    if data <> invalid and type(data) = "roAssociativeArray"

      for each sectionName in data
        sectionData = data[sectionName]
        sectionName = lcase(`${sectionName}`)
        section = createObject("roRegistrySection", sectionName)

        if sectionData <> invalid and type(sectionData) = "roAssociativeArray"

          for each key in sectionData
            value = sectionData[key]
            key = lcase(`${key}`)
            section.write(key, formatJson(value))
          end for

        end if
        section.flush()

      end for

    end if

    reg.flush()
  end function

  public function deleteAll() as void
    reg = createObject("roRegistry")
    sections = reg.getSectionList()

    for each sectionName in sections
      reg.delete(sectionName)
    end for
  end function

  function writeSerializable(section as string, key as string, serializable as object) as boolean
    data = utils.Serialization.serialize(serializable)
    if data <> invalid
      m.write(section, key, data)
      return true
    else
      m.log.warn("asked to write from non-serializebale object")
      return false
    end if
  end function

  function readSerializable(section as string, key as string, serializable = invalid as object) as dynamic
    if utils.Serialization.isSerializable(serializable) or serializable = invalid
      data = m.read(section, key)
      return utils.Serialization.deSerialize(data, serializable)
    else
      m.log.warn("asked to read into non-serializebale object")
    end if
    return false
  end function
end class